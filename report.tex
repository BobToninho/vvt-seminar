\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}

\usepackage{hyperref}

% with the default options it reduces the page margins already
\usepackage{geometry}

% glossary {{{
\usepackage[acronym,automake]{glossaries}
\makeglossaries

% \newglossaryentry{WAUT}
% {
%     name=WAUT,
%     description={Web Application Under Test}
% }
\newacronym{waut}{WAUT}{Web Application Under Test}
% }}}

\title{Report: A formal approach for run-time verification of web applications using scope-extended LTL}
\author{Roberto Tonino}

% % cool font {{{
% \usepackage[utf8]{inputenc}
\usepackage{libertine}
% \usepackage{libertinust1math}
% \usepackage[T1]{fontenc}
% % }}}

% biblatex {{{
\usepackage{biblatex}
\addbibresource{report.bib}
% }}}

\newcommand{\req}[1]{<$u_{#1}$,$c_{#1}$,$I_{#1}$,$L_{#1}$,$V_{#1}$>}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
\label{introduction}

In the paper \citetitle{Haydar2013}, the authors propose a model checking approach for formal verification of user defined properties of web applications. The black-box approach was chosen in order to widen the set of web applications that is possible to verify, because it does not require access to source code and is language-agnostic.

The methodology consists in recording traces of a \gls{waut}, converting them in a communicating-automata model, and feeding the model to the model checker Spin. The properties to verify are specified in LTL, which is the property specification language of Spin.

The authors propose a classification of the states of the automata model in \emph{stable}, where all the windows or displays are fully loaded, and \emph{transient} states.  Because of this, it becomes necessary to specify LTL properties over a subset of the states, and beacuse this is tricky even for an expert, the authors propose a LTL operator that allows to specify a LTL formula over subset of states. This operator doesn't affect the expressiveness of LTL, but helps the user in writing more intuitive and succint formulas.

The authors developed a prototype of the proposed approach and in the paper they present the result of using the prototype in a number of web applications.

\section{Automata-based modeling of web applications}
\label{automata-based-modeling-of-web-applications}


\subsection{Modeling approach}
\label{modeling-approach}

The proposed method is not an exaustive testing like traditional model checking, but should be considered as ``passive testing''. Moreover, the authors consider a setting in which the \gls{waut} does not perform asynchronous requests. In other words, the browser is expected to finish loading a page before a subsequent navigation starts.

The monitoring approach proposed contains three main components or modules---\textit{monitoring} module, \textit{analysis} module and \textit{model checking} module. The monitoring module intercepts HTTP requests and responses of the \gls{waut}. The analysis module generates a Promela model taking as input the intercepted traces. Finally, the model checking module verifies user-defined properties against the model generated by the analysis module and produces a counterexample. It uses the Spin model checker.

\subsection{Single window browsing}
\label{single-window-browsing}

This model is a simplified version of the final model, mostly useful to give the reader a gradual introduction to the approach. We now define \emph{web requests}, \emph{responses}, and \emph{browsing sessions}.

\paragraph{Web request}
A \emph{web request} is represented by the string $l$ and can have two shapes:

\begin{enumerate}
  \item if the HTTP method is GET or HEAD, then $l$ is the URI sent in the request;
  \item if the request comes from a form, then $l = a?d$ with
    \begin{itemize}
      \item $a$ form action
      \item $d$ form data, i.e. the key-value fields filled in the form
    \end{itemize}
\end{enumerate}

\paragraph{Response}
A \emph{response} is represented by the tuple <$u$,$c$,$I$,$L$,$V$> where:

\begin{itemize}
  \item $u$ represents the request $l$;
  \item $c$ is the status code; $c \in C$ with $C$ set of all status codes (cfr. \cite[\S 15]{Fielding2022});
  \item $I$ is the set of URIs specified by the \textit{action} attribute in all the forms of the page;
  \item $L$ is the set of URIs associated with links. It includes implicit links, but excludes links to document fragments;
  \item $V$ is a vector <$v_1$, \dots, $v_k$> where $v_i$ is the valuation of the page attribute $i$ and $k$ is the number of all the page attributes over which the atomic propositions are defined.
\end{itemize}

\paragraph{Browsing session}
A \emph{browsing session} is a Request/Response sequence $RRS =$ \req{0} $l_1$ \req{1} \dots $l_n$ \req{n} where:

\begin{itemize}
  \item $u_0$ and $c_0$ are null, and $I_0$, $L_0$, and $V_0$ are empty;
  \item $l_i$ is a request that is followed by the response page <$u_i$,$c_i$,$I_i$,$L_i$,$V_i$>;
  \item for all $i > 1$, $l_i \in L_{i-1}$ if $l_i$ is a request corresponding to a clicked or implicit link;
  \item if $l_i$ is of the form $a_i?d_i$, then $a_i \in I_{i-1}$;
  \item $n$ is the total number of the requests in the browsing session.
\end{itemize}

\paragraph{Attributes}
$\mathcal{U}$ denotes the set of all user-defined attributes.

\subsubsection{Browsing session as automaton}

The authors present an algorithm to convert an $RRS$ into a so-called \emph{session automaton}. A transition in the session automaton represents a navigation via link or via form submission, while a state represents all the pages with equal valuation attributes and set of links ($L$) and form actions ($I$).

Given a browsing session $RRS =$ \req{0} $l_1$ \req{1} \dots $l_n$ \req{n} where $n$ is the total number of observed requests:

\begin{enumerate}
  \item the tuple \req{0} is mapped to a special state called ``inactive'' and denoted $s_0$. In this state, $u_0$ and $c_0$ are null, and $I_0$, $L_0$, and $V_0$ are empty sets;
  \item for all $i > 0$, a tuple \req{i} corresponds to a state of the automaton. Two tuples \req{i} and \req{j} where $j > i$, are mapped to the same state if:
    \begin{itemize}
      \item $c_i = c_j$; 
      \item $I_i = I_j$; 
      \item $L_i = L_j$; 
      \item and $V_i = V_j$. 
    \end{itemize}
    $S$ denotes the set of such states.

  \item to define the alphabet of the automaton, we first define $\Gamma$, $\Delta$ and $Req$:
    \begin{itemize}
      \item $\Gamma = \displaystyle\bigcup_{i=1}^{n} L_i$;
      \item $\Delta \subseteq \displaystyle\bigcup_{i=1}^{n} I_i$;
      \item $Req$ is the set of all observed requests.
    \end{itemize}
    The alphabet is then easily defined $\Sigma = \Gamma \cup \Delta \cup Req$.

  \item a transition is a triple ($s_i$, $l_{i+1}$, $s_{i+1}$), where:
    \begin{itemize}
      \item $s_i =$\req{i};
      \item $s_{i+1} =$\req{i+1};
      \item  if $l_{i+1}$ is a request corresponding to a clicked or implicit link, then $l_{i+1} \in L_i$ 
      \item otherwise if $l_{i+1}$ is of the form $a_{i+1}?d_{i+1}$, then $a_{i+1} \in I_i$, and  if $c_{i+1} \neq 3xx$, then $l_{i+1} = u_{i+1}$, otherwise $l_{i+1} \neq u_{i+1}$.
    \end{itemize}

  \item Each request corresponding to an \textbf{explored repeated link} or \textbf{explored repeated form} defines a transition from the state to the state that corresponds to the response of the clicked link or the submitted form.
  \item Each event corresponding to an \textbf{unexplored link} $l \in L_i$ or \textbf{unexplored form} $a \in I_i$ defines a transition from the state representing the page \req{i} to a designated state, called a \emph{trap} state that represents the unexplored part of the WAUT and whose attributes are not available. Let $T$ denote the set of such transitions.
\end{enumerate}

The session automaton is $ARRS =$ <$S \cup \{trap\}, s_0, \Sigma, T$>. We define \emph{deduced} states by inferring transitions of links (forms) that are repeated in different pages of the \gls{waut} without being clicked (submitted) in every page where they occur. Deduced states enhance the model obtained by solely considering the traces, increasing the impact of model checking in this setting. Additionally, note that we are merging states which have the same attributes and the same set of outgoing transitions.

[HERE PUT EXAMPLE IN FIG.2]

\subsection{Multiple window browsing}
\label{multiple-window-browsing}

\section{LTL and the ``In'' operator}
\label{ltl-and-the-in-operator}

In order to represent more succintly LTL formulas in the domain of web
applications, the authors extend the LTL syntax with the \textbf{In}
operator.

\section{Results}
\label{results}

\printbibliography

\end{document}

% vi: fdm=marker
